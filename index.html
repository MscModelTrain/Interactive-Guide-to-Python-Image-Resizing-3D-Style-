<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">The Interactive Guide to Image Resizing in Python</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Cool Neutral Tech -->
    <!-- Application Structure Plan: A thematic, single-page application designed for discoverability. The structure flows from fundamentals to advanced topics. It starts with a hero section for context and navigation. 'The Fundamentals' section uses a comparison layout to clarify library differences. The core 'Interpolation Methods' section is an interactive dashboard with a master chart for high-level comparison and detailed tabs for deep dives, allowing users to control the information density. 'Scaling Direction' uses a side-by-side layout to contrast upscaling vs. downscaling. 'Advanced Methods' are presented as distinct cards to separate them from core techniques. This structure moves from broad concepts to specific details, guided by user interaction, making complex information digestible and non-linear. -->
    <!-- Visualization & Content Choices: Report Info -> Goal -> Viz/Presentation -> Interaction -> Justification. 1. Interpolation Comparison -> Compare quality vs. speed -> Bar Chart (Chart.js) -> Static display -> Provides an immediate, high-level visual summary of the primary trade-off. 2. Interpolation Details -> Inform/Organize -> Tabbed content cards (HTML/Tailwind/JS) -> User clicks tabs -> Breaks down dense details into manageable, user-selected chunks, preventing information overload. 3. Library Differences -> Compare -> 3-column card layout (HTML/Tailwind) -> Static display -> Highlights the inconsistencies between libraries side-by-side for easy comparison. 4. Upscaling vs. Downscaling -> Compare/Inform -> 2-column layout (HTML/Tailwind) -> Static display -> Clearly contrasts the two concepts, their challenges, and best practices. All text is summarized from the report for clarity and scannability. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-x: hidden; /* Prevent horizontal scroll due to potential canvas overflow */
        }
        #threejs-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* Place it behind all content */
            pointer-events: none; /* Allow clicks to pass through to elements below */
            opacity: 0.8; /* Subtle transparency */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 50vh;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 450px;
            }
        }
        .tab-active {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
            color: #1e3a8a; /* blue-900 */
        }
        .tab-inactive {
            border-color: transparent;
            background-color: #f3f4f6; /* gray-100 */
            color: #4b5563; /* gray-600 */
        }
        .section-fade-in {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }
        .section-fade-in.visible {
            opacity: 1;
            transform: translateY(0);
        }
        /* Ensure content layers are above the 3D background */
        header, main, footer {
            position: relative;
            z-index: 1;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div id="threejs-background"></div>

    <header class="bg-white/80 backdrop-blur-lg sticky top-0 z-50 shadow-sm">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <h1 class="text-xl font-bold text-slate-900" data-i18n="header_title">Python Image Resizing</h1>
            <div class="hidden md:flex space-x-6 text-sm font-medium">
                <a href="#fundamentals" class="text-slate-600 hover:text-blue-600 transition-colors" data-i18n="nav_fundamentals">Fundamentals</a>
                <a href="#interpolation" class="text-slate-600 hover:text-blue-600 transition-colors" data-i18n="nav_interpolation">Interpolation</a>
                <a href="#direction" class="text-slate-600 hover:text-blue-600 transition-colors" data-i18n="nav_scaling_direction">Scaling Direction</a>
                <a href="#advanced" class="text-slate-600 hover:text-blue-600 transition-colors" data-i18n="nav_advanced">Advanced</a>
            </div>
            <div class="flex items-center space-x-4">
                <select id="language-selector" class="bg-gray-200 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2">
                    <option value="en">English</option>
                    <option value="es">Español</option>
                    <option value="fr">Français</option>
                    <option value="ar">العربية</option>
                </select>
                <div class="md:hidden">
                    <select id="mobile-nav" class="bg-gray-200 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2">
                        <option data-i18n="nav_placeholder">Navigate...</option>
                        <option value="#fundamentals" data-i18n="nav_fundamentals">Fundamentals</option>
                        <option value="#interpolation" data-i18n="nav_interpolation">Interpolation</option>
                        <option value="#direction" data-i18n="nav_scaling_direction">Scaling Direction</option>
                        <option value="#advanced" data-i18n="nav_advanced">Advanced</option>
                    </select>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-6 py-8 md:py-16">

        <section class="text-center mb-16 md:mb-24 section-fade-in">
            <h2 class="text-4xl md:text-6xl font-extrabold text-slate-900 mb-4" data-i18n="hero_title">Mastering Image Resizing</h2>
            <p class="max-w-3xl mx-auto text-lg text-slate-600" data-i18n="hero_description">
                An interactive guide to the methods, trade-offs, and libraries for resizing images in Python. Move beyond simple scaling and learn to choose the right technique for optimal quality and performance.
            </p>
        </section>

        <section id="fundamentals" class="mb-16 md:mb-24 section-fade-in">
            <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-900" data-i18n="fundamentals_section_title">The Fundamentals</h3>
                <p class="text-md text-slate-500 mt-2" data-i18n="fundamentals_section_description">Before diving into code, it's crucial to understand the core concepts and the primary tools available. This section covers the 'what' and 'why' of resizing and introduces the key Python libraries you'll encounter.
                </p>
            </div>

            <div class="grid md:grid-cols-2 gap-8 items-start">
                <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100">
                    <h4 class="text-xl font-semibold text-slate-800 mb-3" data-i18n="why_resize_title">Why Resize? The Core Concepts</h4>
                    <p class="text-slate-600 mb-4" data-i18n="why_resize_description">Image resizing is the process of changing an image's dimensions. It's a fundamental task driven by two main goals: optimizing performance (e.g., smaller files for websites) and preparing data (e.g., standardizing sizes for machine learning models).</p>
                    <div class="bg-amber-50 border-l-4 border-amber-400 p-4 rounded-r-lg">
                        <h5 class="font-bold text-amber-900" data-i18n="aspect_ratio_rule_title">The Golden Rule: Aspect Ratio</h5>
                        <p class="text-amber-800 text-sm" data-i18n="aspect_ratio_rule_description">Preserving the aspect ratio (the proportional relationship between width and height) is paramount. Stretching or squashing an image by ignoring its original proportions leads to distortion. The first decision in any resize operation is whether to maintain this ratio.</p>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100">
                     <h4 class="text-xl font-semibold text-slate-800 mb-3" data-i18n="python_toolbox_title">The Python Toolbox</h4>
                    <p class="text-slate-600 mb-4" data-i18n="python_toolbox_description">Python's ecosystem offers several powerful libraries for image manipulation. While they achieve similar goals, their APIs and default behaviors differ significantly, requiring careful attention.</p>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 text-center text-sm">
                        <div class="p-3 bg-slate-100 rounded-lg">
                            <h5 class="font-bold text-slate-700" data-i18n="pillow_title">Pillow (PIL Fork)</h5>
                            <p class="text-slate-600 mt-1" data-i18n="pillow_description">A user-friendly, general-purpose library. Its `resize()` method can distort aspect ratio, while `thumbnail()` preserves it.</p>
                        </div>
                        <div class="p-3 bg-slate-100 rounded-lg">
                            <h5 class="font-bold text-slate-700" data-i18n="opencv_title">OpenCV</h5>
                             <p class="text-slate-600 mt-1" data-i18n="opencv_description">A computer vision powerhouse. Its `cv2.resize()` is versatile but requires careful handling of parameters to maintain aspect ratio.</p>
                        </div>
                        <div class="p-3 bg-slate-100 rounded-lg">
                            <h5 class="font-bold text-slate-700" data-i18n="scikit_image_title">Scikit-image</h5>
                             <p class="text-slate-600 mt-1" data-i18n="scikit_image_description">Built for scientific analysis, it offers robust resizing with explicit anti-aliasing controls crucial for quality downsampling.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="interpolation" class="mb-16 md:mb-24 section-fade-in">
             <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-900" data-i18n="interpolation_section_title">The Core Technique: Interpolation</h3>
                <p class="text-md text-slate-500 mt-2" data-i18n="interpolation_section_description">Interpolation is the mathematical heart of resizing—it's how new pixel values are estimated. The method you choose directly impacts the final image's quality, speed of processing, and the visual artifacts produced. There is no single "best" method; it's always a trade-off.
                </p>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg border border-slate-200 mb-8">
                 <h4 class="text-xl font-semibold text-center text-slate-800 mb-4" data-i18n="comparison_chart_title">Comparing Methods: Quality vs. Speed</h4>
                <div class="chart-container">
                    <canvas id="interpolationChart"></canvas>
                </div>
            </div>

            <div id="tabs-container">
                <div class="border-b border-gray-200 mb-6">
                    <nav class="-mb-px flex space-x-2 sm:space-x-4" aria-label="Tabs">
                        <button class="tab whitespace-nowrap py-3 px-3 sm:px-4 border-b-2 font-medium text-sm rounded-t-lg transition-colors duration-200" data-tab="nearest" data-i18n="tab_nearest">Nearest Neighbor</button>
                        <button class="tab whitespace-nowrap py-3 px-3 sm:px-4 border-b-2 font-medium text-sm rounded-t-lg transition-colors duration-200" data-tab="bilinear" data-i18n="tab_bilinear">Bilinear</button>
                        <button class="tab whitespace-nowrap py-3 px-3 sm:px-4 border-b-2 font-medium text-sm rounded-t-lg transition-colors duration-200" data-tab="bicubic" data-i18n="tab_bicubic">Bicubic</button>
                        <button class="tab whitespace-nowrap py-3 px-3 sm:px-4 border-b-2 font-medium text-sm rounded-t-lg transition-colors duration-200" data-tab="lanczos" data-i18n="tab_lanczos">Lanczos</button>
                        <button class="tab whitespace-nowrap py-3 px-3 sm:px-4 border-b-2 font-medium text-sm rounded-t-lg transition-colors duration-200" data-tab="area" data-i18n="tab_area">Area</button>
                    </nav>
                </div>

                <div id="tab-content" class="bg-white p-6 rounded-xl shadow-md border border-slate-100">
                </div>
            </div>
        </section>
        
        <section id="direction" class="mb-16 md:mb-24 section-fade-in">
            <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-900" data-i18n="scaling_direction_section_title">Scaling Direction Matters</h3>
                <p class="text-md text-slate-500 mt-2" data-i18n="scaling_direction_section_description">The challenges and best practices for resizing an image are fundamentally different depending on whether you are making it smaller (downscaling) or larger (upscaling). Choosing the right interpolation method for the job is critical for achieving high-quality results.</p>
            </div>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100">
                    <h4 class="text-2xl font-bold text-red-700 mb-3" data-i18n="downscaling_title">▼ Downscaling (Shrinking)</h4>
                    <p class="text-slate-600 mb-4" data-i18n="downscaling_description">Downscaling throws away pixel information. The main challenge is to do this gracefully without introducing ugly artifacts. The key is <strong class="font-semibold text-slate-800" data-i18n="anti_aliasing_bold">anti-aliasing</strong>, a process of pre-smoothing the image before removing pixels to prevent jagged edges and moiré patterns.</p>
                    <div class="mt-4">
                        <h5 class="font-semibold text-slate-800 mb-2" data-i18n="downscaling_recommended_title">Recommended Methods:</h5>
                        <ul class="list-disc list-inside space-y-1 text-slate-600">
                            <li><strong class="text-slate-700" data-i18n="downscaling_area_method">Area (`cv2.INTER_AREA`):</strong> <span data-i18n="downscaling_area_desc">The gold standard. Averages pixel values over an area, producing clean, sharp results with minimal artifacts.</span></li>
                            <li><strong class="text-slate-700" data-i18n="downscaling_lanczos_bicubic_method">Lanczos/Bicubic with Anti-Aliasing:</strong> <span data-i18n="downscaling_lanczos_bicubic_desc">High-quality interpolators, when paired with an anti-aliasing filter (like in Pillow or Scikit-image), also yield excellent results.</span></li>
                        </ul>
                    </div>
                </div>
                 <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100">
                    <h4 class="text-2xl font-bold text-green-700 mb-3" data-i18n="upscaling_title">▲ Upscaling (Enlarging)</h4>
                    <p class="text-slate-600 mb-4" data-i18n="upscaling_description">Upscaling creates new pixels through estimation. Crucially, traditional methods <strong class="font-semibold text-slate-800" data-i18n="cannot_create_info_bold">cannot create new information</strong>; they can only guess what should go between existing pixels. This sets a quality ceiling and can lead to blurriness or pixelation if overdone.</p>
                     <div class="mt-4">
                        <h5 class="font-semibold text-slate-800 mb-2" data-i18n="upscaling_recommended_title">Recommended Methods:</h5>
                        <ul class="list-disc list-inside space-y-1 text-slate-600">
                            <li><strong class="text-slate-700" data-i18n="upscaling_bicubic_method">Bicubic (`cv2.INTER_CUBIC`):</strong> <span data-i18n="upscaling_bicubic_desc">A great balance of quality and performance. It considers 16 surrounding pixels to produce sharper results than Bilinear.</span></li>
                            <li><strong class="text-slate-700" data-i18n="upscaling_lanczos_method">Lanczos (`cv2.INTER_LANCZOS4`):</strong> <span data-i18n="upscaling_lanczos_desc">Often provides the highest quality for upscaling, preserving fine details exceptionally well, but is computationally more expensive.</span></li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section id="advanced" class="section-fade-in">
             <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-900" data-i18n="advanced_section_title">Beyond Interpolation: Advanced Techniques</h3>
                <p class="text-md text-slate-500 mt-2" data-i18n="advanced_section_description">When traditional methods hit their quality limits, advanced, content-aware techniques offer a path forward. These methods analyze the image's content to perform more intelligent resizing, especially for complex or quality-critical scenarios.</p>
            </div>
             <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100 flex flex-col">
                    <h4 class="text-xl font-semibold text-slate-800 mb-3" data-i18n="seam_carving_title">Content-Aware Resizing (Seam Carving)</h4>
                    <p class="text-slate-600 mb-4 flex-grow" data-i18n="seam_carving_description">Instead of scaling uniformly, this technique identifies and removes or duplicates "seams" of the least important pixels. It resizes the image non-uniformly, protecting important objects from distortion. This is ideal for changing an image's aspect ratio without squashing the main subject.</p>
                    <div class="mt-auto pt-4 border-t border-slate-200">
                        <span class="text-sm font-semibold text-blue-600 bg-blue-100 py-1 px-3 rounded-full" data-i18n="seam_carving_use_case">Use Case: Aspect ratio change while preserving subjects</span>
                    </div>
                </div>
                 <div class="bg-white p-6 rounded-xl shadow-md border border-slate-100 flex flex-col">
                    <h4 class="text-xl font-semibold text-slate-800 mb-3" data-i18n="super_resolution_title">Super-Resolution (Deep Learning)</h4>
                    <p class="text-slate-600 mb-4 flex-grow" data-i18n="super_resolution_description">This is the modern solution to the upscaling problem. Instead of just interpolating, deep learning models are trained to "hallucinate" plausible high-frequency details. They genuinely add new, realistic information, resulting in dramatically sharper and more detailed enlargements than any traditional method can achieve.</p>
                    <div class="mt-auto pt-4 border-t border-slate-200">
                        <span class="text-sm font-semibold text-purple-600 bg-purple-100 py-1 px-3 rounded-full" data-i18n="super_resolution_use_case">Use Case: High-quality, large-scale image enlargement</span>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="bg-slate-800 text-slate-400 mt-16">
        <div class="container mx-auto px-6 py-8 text-center">
            <p data-i18n="footer_line1">Interactive guide created from the "Python Image Resizing Methods" report.</p>
            <p class="text-sm mt-2" data-i18n="footer_line2">Designed to make complex image processing concepts accessible and understandable.</p>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const translations = {
                en: {
                    page_title: "The Interactive Guide to Image Resizing in Python",
                    header_title: "Python Image Resizing",
                    nav_fundamentals: "Fundamentals",
                    nav_interpolation: "Interpolation",
                    nav_scaling_direction: "Scaling Direction",
                    nav_advanced: "Advanced",
                    nav_placeholder: "Navigate...",
                    hero_title: "Mastering Image Resizing",
                    hero_description: "An interactive guide to the methods, trade-offs, and libraries for resizing images in Python. Move beyond simple scaling and learn to choose the right technique for optimal quality and performance.",
                    fundamentals_section_title: "The Fundamentals",
                    fundamentals_section_description: "Before diving into code, it's crucial to understand the core concepts and the primary tools available. This section covers the 'what' and 'why' of resizing and introduces the key Python libraries you'll encounter.",
                    why_resize_title: "Why Resize? The Core Concepts",
                    why_resize_description: "Image resizing is the process of changing an image's dimensions. It's a fundamental task driven by two main goals: optimizing performance (e.g., smaller files for websites) and preparing data (e.g., standardizing sizes for machine learning models).",
                    aspect_ratio_rule_title: "The Golden Rule: Aspect Ratio",
                    aspect_ratio_rule_description: "Preserving the aspect ratio (the proportional relationship between width and height) is paramount. Stretching or squashing an image by ignoring its original proportions leads to distortion. The first decision in any resize operation is whether to maintain this ratio.",
                    python_toolbox_title: "The Python Toolbox",
                    python_toolbox_description: "Python's ecosystem offers several powerful libraries for image manipulation. While they achieve similar goals, their APIs and default behaviors differ significantly, requiring careful attention.",
                    pillow_title: "Pillow (PIL Fork)",
                    pillow_description: "A user-friendly, general-purpose library. Its `resize()` method can distort aspect ratio, while `thumbnail()` preserves it.",
                    opencv_title: "OpenCV",
                    opencv_description: "A computer vision powerhouse. Its `cv2.resize()` is versatile but requires careful handling of parameters to maintain aspect ratio.",
                    scikit_image_title: "Scikit-image",
                    scikit_image_description: "Built for scientific analysis, it offers robust resizing with explicit anti-aliasing controls crucial for quality downsampling.",
                    interpolation_section_title: "The Core Technique: Interpolation",
                    interpolation_section_description: "Interpolation is the mathematical heart of resizing—it's how new pixel values are estimated. The method you choose directly impacts the final image's quality, speed of processing, and the visual artifacts produced. There is no single \"best\" method; it's always a trade-off.",
                    comparison_chart_title: "Comparing Methods: Quality vs. Speed",
                    chart_quality_label: "Relative Quality",
                    chart_speed_label: "Relative Speed",
                    tab_nearest: "Nearest Neighbor",
                    tab_bilinear: "Bilinear",
                    tab_bicubic: "Bicubic",
                    tab_lanczos: "Lanczos",
                    tab_area: "Area",
                    nearest_title: "Nearest Neighbor Interpolation",
                    nearest_description: "The simplest and fastest method. It assigns the new pixel the exact value of the single closest pixel from the original image. Conceptually, it just makes existing pixels bigger.",
                    nearest_pros: ["Extremely fast, minimal processing", "Preserves sharp edges without blurring", "Good for pixel art and discrete data"],
                    nearest_cons: ["Produces blocky, jagged results ('jaggies')", "Lacks smoothness, visually unappealing for photos"],
                    nearest_artifact: "Blockiness & Jagged Edges",
                    nearest_bestFor: "Real-time applications, scaling pixel art, or when speed is the only concern.",
                    bilinear_title: "Bilinear Interpolation",
                    bilinear_description: "A step up in quality. It calculates a new pixel's value by taking a weighted average of the 4 (2x2) surrounding pixels. It produces much smoother results than Nearest Neighbor.",
                    bilinear_pros: ["Good balance between speed and quality", "Significantly reduces jaggedness", "Relatively fast"],
                    bilinear_cons: ["Can introduce some blurring", "Loses some fine detail compared to more advanced methods"],
                    bilinear_artifact: "Blurriness",
                    bilinear_bestFor: "General purpose resizing where a decent compromise between speed and quality is needed.",
                    bicubic_title: "Bicubic Interpolation",
                    bicubic_description: "A more advanced method that considers a 4x4 neighborhood of 16 pixels. It uses more complex calculations (cubic polynomials) to produce sharper, more detailed images.",
                    bicubic_pros: ["Excellent quality with great detail retention", "Produces smoother gradations than bilinear", "Often the 'sweet spot' for quality"],
                    bicubic_cons: ["Significantly slower than bilinear", "Can create 'haloing' or 'overshoot' artifacts along sharp edges"],
                    bicubic_artifact: "Overshoot / Haloing",
                    bicubic_bestFor: "High-quality photo enlargement and professional applications where quality is a priority.",
                    lanczos_title: "Lanczos Interpolation",
                    lanczos_description: "A high-quality interpolation method based on a sinc function. It considers an even larger neighborhood (typically 8x8) to produce very sharp results, but at a higher computational cost.",
                    lanczos_pros: ["Superior sharpness and detail preservation", "Minimizes aliasing artifacts effectively", "Retains more information through multiple transformations"],
                    lanczos_cons: ["Very computationally intensive (slow)", "Can produce noticeable 'ringing' artifacts along strong edges"],
                    lanczos_artifact: "Ringing Artifacts",
                    lanczos_bestFor: "Archival-quality scaling, video upscaling, and scenarios where maximum detail preservation is critical.",
                    area_title: "Area Interpolation (cv2.INTER_AREA)",
                    area_description: "A specialized method primarily for downscaling (shrinking images). It resamples by considering the pixel area relation, effectively averaging the pixels in a source area to create a single pixel in the destination.",
                    area_pros: ["Produces sharp, artifact-free results when downscaling", "Excellent at preventing moiré patterns", "Specifically designed for shrinking"],
                    area_cons: ["Performs very poorly for upscaling (similar to Nearest Neighbor)"],
                    area_artifact: "Poor quality on upscaling",
                    area_bestFor: "Exclusively for downscaling/shrinking images. It's the recommended method for this task in OpenCV.",
                    tab_key_characteristics: "Key Characteristics:",
                    tab_primary_artifact: "Primary Artifact:",
                    tab_best_for: "Best For:",
                    scaling_direction_section_title: "Scaling Direction Matters",
                    scaling_direction_section_description: "The challenges and best practices for resizing an image are fundamentally different depending on whether you are making it smaller (downscaling) or larger (upscaling). Choosing the right interpolation method for the job is critical for achieving high-quality results.",
                    downscaling_title: "▼ Downscaling (Shrinking)",
                    downscaling_description: "Downscaling throws away pixel information. The main challenge is to do this gracefully without introducing ugly artifacts. The key is ",
                    anti_aliasing_bold: "anti-aliasing",
                    downscaling_recommended_title: "Recommended Methods:",
                    downscaling_area_method: "Area (`cv2.INTER_AREA`):",
                    downscaling_area_desc: "The gold standard. Averages pixel values over an area, producing clean, sharp results with minimal artifacts.",
                    downscaling_lanczos_bicubic_method: "Lanczos/Bicubic with Anti-Aliasing:",
                    downscaling_lanczos_bicubic_desc: "High-quality interpolators, when paired with an anti-aliasing filter (like in Pillow or Scikit-image), also yield excellent results.",
                    upscaling_title: "▲ Upscaling (Enlarging)",
                    upscaling_description: "Upscaling creates new pixels through estimation. Crucially, traditional methods ",
                    cannot_create_info_bold: "cannot create new information",
                    upscaling_recommended_title: "Recommended Methods:",
                    upscaling_bicubic_method: "Bicubic (`cv2.INTER_CUBIC`):",
                    upscaling_bicubic_desc: "A great balance of quality and performance. It considers 16 surrounding pixels to produce sharper results than Bilinear.",
                    upscaling_lanczos_method: "Lanczos (`cv2.INTER_LANCZOS4`):",
                    upscaling_lanczos_desc: "Often provides the highest quality for upscaling, preserving fine details exceptionally well, but is computationally more expensive.",
                    advanced_section_title: "Beyond Interpolation: Advanced Techniques",
                    advanced_section_description: "When traditional methods hit their quality limits, advanced, content-aware techniques offer a path forward. These methods analyze the image's content to perform more intelligent resizing, especially for complex or quality-critical scenarios.",
                    seam_carving_title: "Content-Aware Resizing (Seam Carving)",
                    seam_carving_description: "Instead of scaling uniformly, this technique identifies and removes or duplicates \"seams\" of the least important pixels. It resizes the image non-uniformly, protecting important objects from distortion. This is ideal for changing an image's aspect ratio without squashing the main subject.",
                    seam_carving_use_case: "Use Case: Aspect ratio change while preserving subjects",
                    super_resolution_title: "Super-Resolution (Deep Learning)",
                    super_resolution_description: "This is the modern solution to the upscaling problem. Instead of just interpolating, deep learning models are trained to \"hallucinate\" plausible high-frequency details. They genuinely add new, realistic information, resulting in dramatically sharper and more detailed enlargements than any traditional method can achieve.",
                    super_resolution_use_case: "Use Case: High-quality, large-scale image enlargement",
                    footer_line1: "Interactive guide created from the \"Python Image Resizing Methods\" report.",
                    footer_line2: "Designed to make complex image processing concepts accessible and understandable."
                },
                es: {
                    page_title: "La Guía Interactiva para Redimensionar Imágenes en Python",
                    header_title: "Redimensionamiento de Imágenes en Python",
                    nav_fundamentals: "Fundamentos",
                    nav_interpolation: "Interpolación",
                    nav_scaling_direction: "Dirección de Escalado",
                    nav_advanced: "Avanzado",
                    nav_placeholder: "Navegar...",
                    hero_title: "Dominando el Redimensionamiento de Imágenes",
                    hero_description: "Una guía interactiva sobre los métodos, compensaciones y librerías para redimensionar imágenes en Python. Vaya más allá del escalado simple y aprenda a elegir la técnica adecuada para una calidad y rendimiento óptimos.",
                    fundamentals_section_title: "Los Fundamentos",
                    fundamentals_section_description: "Antes de sumergirse en el código, es crucial comprender los conceptos centrales y las herramientas principales disponibles. Esta sección cubre el 'qué' y el 'por qué' del redimensionamiento e introduce las librerías clave de Python que encontrará.",
                    why_resize_title: "¿Por qué Redimensionar? Los Conceptos Clave",
                    why_resize_description: "El redimensionamiento de imágenes es el proceso de cambiar las dimensiones de una imagen. Es una tarea fundamental impulsada por dos objetivos principales: optimizar el rendimiento (ej., archivos más pequeños para sitios web) y preparar datos (ej., estandarizar tamaños para modelos de aprendizaje automático).",
                    aspect_ratio_rule_title: "La Regla de Oro: Relación de Aspecto",
                    aspect_ratio_rule_description: "Preservar la relación de aspecto (la relación proporcional entre ancho y alto) es primordial. Estirar o comprimir una imagen ignorando sus proporciones originales lleva a la distorsión. La primera decisión en cualquier operación de redimensionamiento es si mantener esta relación.",
                    python_toolbox_title: "La Caja de Herramientas de Python",
                    python_toolbox_description: "El ecosistema de Python ofrece varias librerías potentes para la manipulación de imágenes. Aunque logran objetivos similares, sus APIs y comportamientos predeterminados difieren significativamente, requiriendo una atención cuidadosa.",
                    pillow_title: "Pillow (Fork de PIL)",
                    pillow_description: "Una librería amigable y de propósito general. Su método `resize()` puede distorsionar la relación de aspecto, mientras que `thumbnail()` la conserva.",
                    opencv_title: "OpenCV",
                    opencv_description: "Una potencia en visión por computadora. Su `cv2.resize()` es versátil pero requiere un manejo cuidadoso de los parámetros para mantener la relación de aspecto.",
                    scikit_image_title: "Scikit-image",
                    scikit_image_description: "Construida para el análisis científico, ofrece un redimensionamiento robusto con controles explícitos de anti-aliasing cruciales para el muestreo descendente de calidad.",
                    interpolation_section_title: "La Técnica Central: Interpolación",
                    interpolation_section_description: "La interpolación es el corazón matemático del redimensionamiento: es cómo se estiman los nuevos valores de píxel. El método que elija afecta directamente la calidad final de la imagen, la velocidad de procesamiento y los artefactos visuales producidos. No hay un método \"mejor\" único; siempre es una compensación.",
                    comparison_chart_title: "Comparando Métodos: Calidad vs. Velocidad",
                    chart_quality_label: "Calidad Relativa",
                    chart_speed_label: "Velocidad Relativa",
                    tab_nearest: "Vecino Más Cercano",
                    tab_bilinear: "Bilineal",
                    tab_bicubic: "Bicúbica",
                    tab_lanczos: "Lanczos",
                    tab_area: "Área",
                    nearest_title: "Interpolación por Vecino Más Cercano",
                    nearest_description: "El método más simple y rápido. Asigna al nuevo píxel el valor exacto del píxel más cercano de la imagen original. Conceptualmente, simplemente agranda los píxeles existentes.",
                    nearest_pros: ["Extremadamente rápido, procesamiento mínimo", "Conserva los bordes nítidos sin desenfoque", "Bueno para arte de píxeles y datos discretos"],
                    nearest_cons: ["Produce resultados pixelados y dentados ('jaggies')", "Carece de suavidad, visualmente poco atractivo para fotos"],
                    nearest_artifact: "Pixelación y Bordes Dentados",
                    nearest_bestFor: "Aplicaciones en tiempo real, escalado de arte de píxeles, o cuando la velocidad es la única preocupación.",
                    bilinear_title: "Interpolación Bilineal",
                    bilinear_description: "Un paso adelante en calidad. Calcula el valor de un nuevo píxel tomando un promedio ponderado de los 4 (2x2) píxeles circundantes. Produce resultados mucho más suaves que el Vecino Más Cercano.",
                    bilinear_pros: ["Buen equilibrio entre velocidad y calidad", "Reduce significativamente el dentado", "Relativamente rápido"],
                    bilinear_cons: ["Puede introducir cierto desenfoque", "Pierde algunos detalles finos en comparación con métodos más avanzados"],
                    bilinear_artifact: "Desenfoque",
                    bilinear_bestFor: "Redimensionamiento de propósito general donde se necesita un compromiso decente entre velocidad y calidad.",
                    bicubic_title: "Interpolación Bicúbica",
                    bicubic_description: "Un método más avanzado que considera un vecindario de 4x4 de 16 píxeles. Utiliza cálculos más complejos (polinomios cúbicos) para producir imágenes más nítidas y detalladas.",
                    bicubic_pros: ["Excelente calidad con gran retención de detalles", "Produce gradaciones más suaves que la bilineal", "A menudo el 'punto óptimo' para la calidad"],
                    bicubic_cons: ["Significativamente más lento que la bilineal", "Puede crear artefactos de 'halo' o 'sobrepaso' a lo largo de bordes nítidos"],
                    bicubic_artifact: "Sobrepaso / Halo",
                    bicubic_bestFor: "Ampliación de fotos de alta calidad y aplicaciones profesionales donde la calidad es una prioridad.",
                    lanczos_title: "Interpolación Lanczos",
                    lanczos_description: "Un método de interpolación de alta calidad basado en una función sinc. Considera un vecindario aún más grande (típicamente 8x8) para producir resultados muy nítidos, pero con un costo computacional más alto.",
                    lanczos_pros: ["Nitidez superior y preservación de detalles", "Minimiza eficazmente los artefactos de aliasing", "Retiene más información a través de múltiples transformaciones"],
                    lanczos_cons: ["Muy intensivo computacionalmente (lento)", "Puede producir artefactos de 'anillo' notables a lo largo de bordes fuertes"],
                    lanczos_artifact: "Artefactos de Anillo",
                    lanczos_bestFor: "Escalado de calidad de archivo, escalado de video y escenarios donde la máxima preservación de detalles es crítica.",
                    area_title: "Interpolación de Área (cv2.INTER_AREA)",
                    area_description: "Un método especializado principalmente para el muestreo descendente (reducción de imágenes). Remuestrea considerando la relación de área de píxeles, promediando efectivamente los valores de píxel en un área de origen para crear un solo píxel en el destino.",
                    area_pros: ["Produce resultados nítidos y sin artefactos al reducir el tamaño", "Excelente para prevenir patrones de muaré", "Diseñado específicamente para reducir"],
                    area_cons: ["Funciona muy mal para el escalado (similar a Vecino Más Cercano)"],
                    area_artifact: "Mala calidad en el escalado",
                    area_bestFor: "Exclusivamente para la reducción de imágenes. Es el método recomendado para esta tarea en OpenCV.",
                    tab_key_characteristics: "Características Clave:",
                    tab_primary_artifact: "Artefacto Principal:",
                    tab_best_for: "Mejor Para:",
                    scaling_direction_section_title: "La Dirección de Escalado Importa",
                    scaling_direction_section_title: "La Dirección de Escalado Importa",
                    scaling_direction_section_description: "Los desafíos y las mejores prácticas para redimensionar una imagen son fundamentalmente diferentes dependiendo de si la está haciendo más pequeña (escalado descendente) o más grande (escalado ascendente). Elegir el método de interpolación correcto para el trabajo es fundamental para lograr resultados de alta calidad.",
                    downscaling_title: "▼ Escalado Descendente (Reducción)",
                    downscaling_description: "El escalado descendente descarta información de píxeles. El principal desafío es hacerlo con gracia sin introducir artefactos feos. La clave es el ",
                    anti_aliasing_bold: "anti-aliasing",
                    downscaling_recommended_title: "Métodos Recomendados:",
                    downscaling_area_method: "Área (`cv2.INTER_AREA`):",
                    downscaling_area_desc: "El estándar de oro. Promedia los valores de los píxeles en un área, produciendo resultados limpios y nítidos con artefactos mínimos.",
                    downscaling_lanczos_bicubic_method: "Lanczos/Bicúbica con Anti-Aliasing:",
                    downscaling_lanczos_bicubic_desc: "Interpoladores de alta calidad, cuando se combinan con un filtro anti-aliasing (como en Pillow o Scikit-image), también producen excelentes resultados.",
                    upscaling_title: "▲ Escalado Ascendente (Ampliación)",
                    upscaling_description: "El escalado ascendente crea nuevos píxeles mediante estimación. Crucialmente, los métodos tradicionales ",
                    cannot_create_info_bold: "no pueden crear nueva información",
                    upscaling_recommended_title: "Métodos Recomendados:",
                    upscaling_bicubic_method: "Bicúbica (`cv2.INTER_CUBIC`):",
                    upscaling_bicubic_desc: "Un gran equilibrio entre calidad y rendimiento. Considera 16 píxeles circundantes para producir resultados más nítidos que la Bilineal.",
                    upscaling_lanczos_method: "Lanczos (`cv2.INTER_LANCZOS4`):",
                    upscaling_lanczos_desc: "A menudo proporciona la más alta calidad para el escalado, preservando los detalles finos excepcionalmente bien, pero es computacionalmente más costoso.",
                    advanced_section_title: "Más Allá de la Interpolación: Técnicas Avanzadas",
                    advanced_section_description: "Cuando los métodos tradicionales alcanzan sus límites de calidad, las técnicas avanzadas y conscientes del contenido ofrecen un camino a seguir. Estos métodos analizan el contenido de la imagen para realizar un redimensionamiento más inteligente, especialmente para escenarios complejos o críticos para la calidad.",
                    seam_carving_title: "Redimensionamiento Consciente del Contenido (Seam Carving)",
                    seam_carving_description: "En lugar de escalar uniformemente, esta técnica identifica y elimina o duplica \"costuras\", que son rutas de píxeles con baja importancia. Redimensiona la imagen de forma no uniforme, protegiendo los objetos importantes de la distorsión. Esto es ideal para cambiar la relación de aspecto de una imagen sin aplastar el sujeto principal.",
                    seam_carving_use_case: "Caso de Uso: Cambio de relación de aspecto preservando sujetos",
                    super_resolution_title: "Súper-Resolución (Aprendizaje Profundo)",
                    super_resolution_description: "Esta es la solución moderna al problema del escalado. En lugar de solo interpolar, los modelos de aprendizaje profundo se entrenan para \"alucinar\" detalles plausibles de alta frecuencia. Realmente añaden información nueva y realista, lo que resulta en ampliaciones dramáticamente más nítidas y detalladas de lo que cualquier método tradicional puede lograr.",
                    super_resolution_use_case: "Caso de Uso: Ampliación de imagen a gran escala y alta calidad",
                    footer_line1: "Guía interactiva creada a partir del informe \"Métodos de Redimensionamiento de Imágenes en Python\".",
                    footer_line2: "Diseñada para hacer que los conceptos complejos de procesamiento de imágenes sean accesibles y comprensibles."
                },
                fr: {
                    page_title: "Le Guide Interactif du Redimensionnement d'Images en Python",
                    header_title: "Redimensionnement d'Images Python",
                    nav_fundamentals: "Fondamentaux",
                    nav_interpolation: "Interpolation",
                    nav_scaling_direction: "Direction de Mise à l'Échelle",
                    nav_advanced: "Avancé",
                    nav_placeholder: "Naviguer...",
                    hero_title: "Maîtriser le Redimensionnement d'Images",
                    hero_description: "Un guide interactif sur les méthodes, les compromis et les bibliothèques pour le redimensionnement d'images en Python. Allez au-delà de la simple mise à l'échelle et apprenez à choisir la bonne technique pour une qualité et des performances optimales.",
                    fundamentals_section_title: "Les Fondamentaux",
                    fundamentals_section_description: "Avant de plonger dans le code, il est crucial de comprendre les concepts de base et les principaux outils disponibles. Cette section couvre le 'quoi' et le 'pourquoi' du redimensionnement et présente les principales bibliothèques Python que vous rencontrerez.",
                    why_resize_title: "Pourquoi Redimensionner ? Les Concepts Clés",
                    why_resize_description: "Le redimensionnement d'images est le processus de modification des dimensions d'une image. C'est une tâche fondamentale motivée par deux objectifs principaux : l'optimisation des performances (par exemple, des fichiers plus petits pour les sites web) et la préparation des données (par exemple, la normalisation des tailles pour les modèles d'apprentissage automatique).",
                    aspect_ratio_rule_title: "La Règle d'Or : Rapport d'Aspect",
                    aspect_ratio_rule_description: "Préserver le rapport d'aspect (la relation proportionnelle entre la largeur et la hauteur) est primordial. Étirer ou compresser une image en ignorant ses proportions originales entraîne une distorsion. La première décision dans toute opération de redimensionnement est de maintenir ce rapport.",
                    python_toolbox_title: "La Boîte à Outils Python",
                    python_toolbox_description: "L'écosystème Python offre plusieurs bibliothèques puissantes pour la manipulation d'images. Bien qu'elles atteignent des objectifs similaires, leurs API et leurs comportements par défaut diffèrent considérablement, nécessitant une attention particulière.",
                    pillow_title: "Pillow (Fork de PIL)",
                    pillow_description: "Une bibliothèque conviviale et polyvalente. Sa méthode `resize()` peut déformer le rapport d'aspect, tandis que `thumbnail()` le préserve.",
                    opencv_title: "OpenCV",
                    opencv_description: "Une puissance en vision par ordinateur. Son `cv2.resize()` est polyvalent mais nécessite une manipulation soignée des paramètres pour maintenir le rapport d'aspect.",
                    scikit_image_title: "Scikit-image",
                    scikit_image_description: "Conçue pour l'analyse scientifique, elle offre un redimensionnement robuste avec des contrôles explicites d'anti-aliasing cruciaux pour un sous-échantillonnage de qualité.",
                    interpolation_section_title: "La Technique Principale : Interpolation",
                    interpolation_section_description: "L'interpolation est le cœur mathématique du redimensionnement : c'est ainsi que les nouvelles valeurs de pixels sont estimées. La méthode que vous choisissez a un impact direct sur la qualité finale de l'image, la vitesse de traitement et les artefacts visuels produits. Il n'y a pas de méthode \"meilleure\" unique ; c'est toujours un compromis.",
                    comparison_chart_title: "Comparaison des Méthodes : Qualité vs. Vitesse",
                    chart_quality_label: "Qualité Relative",
                    chart_speed_label: "Vitesse Relative",
                    tab_nearest: "Plus Proche Voisin",
                    tab_bilinear: "Bilinéaire",
                    tab_bicubic: "Bicubique",
                    tab_lanczos: "Lanczos",
                    tab_area: "Zone",
                    nearest_title: "Interpolation du Plus Proche Voisin",
                    nearest_description: "La méthode la plus simple et la plus rapide. Elle attribue au nouveau pixel la valeur exacte du pixel unique le plus proche de l'image originale. Conceptuellement, elle rend simplement les pixels existants plus grands.",
                    nearest_pros: ["Extrêmement rapide, traitement minimal", "Préserve les bords nets sans flou", "Bon pour le pixel art et les données discrètes"],
                    nearest_cons: ["Produit des résultats pixélisés et crénelés ('jaggies')", "Manque de douceur, visuellement peu attrayant pour les photos"],
                    nearest_artifact: "Pixellisation et Bords Crénelés",
                    nearest_bestFor: "Applications en temps réel, mise à l'échelle de pixel art, ou lorsque la vitesse est la seule préoccupation.",
                    bilinear_title: "Interpolation Bilinéaire",
                    bilinear_description: "Un pas en avant en qualité. Elle calcule la valeur d'un nouveau pixel en prenant une moyenne pondérée des 4 (2x2) pixels environnants. Elle produit des résultats beaucoup plus lisses que le Plus Proche Voisin.",
                    bilinear_pros: ["Bon équilibre entre vitesse et qualité", "Réduit significativement le crénelage", "Relativement rapide"],
                    bilinear_cons: ["Peut introduire un certain flou", "Perte de certains détails fins par rapport aux méthodes plus avancées"],
                    bilinear_artifact: "Flou",
                    bilinear_bestFor: "Redimensionnement général où un compromis décent entre vitesse et qualité est nécessaire.",
                    bicubic_title: "Interpolation Bicubique",
                    bicubic_description: "Une méthode plus avancée qui considère un voisinage 4x4 de 16 pixels. Elle utilise des calculs plus complexes (polynômes cubiques) pour produire des images plus nettes et plus détaillées.",
                    bicubic_pros: ["Excellente qualité avec une grande rétention des détails", "Produit des dégradés plus doux que la bilinéaire", "Souvent le 'juste milieu' pour la qualité"],
                    bicubic_cons: ["Sensiblement plus lente que la bilinéaire", "Peut créer des artefacts de 'halo' ou de 'dépassement' le long des bords nets"],
                    bicubic_artifact: "Dépassement / Halo",
                    bicubic_bestFor: "Agrandissement de photos de haute qualité et applications professionnelles où la qualité est une priorité.",
                    lanczos_title: "Interpolation Lanczos",
                    lanczos_description: "Une méthode d'interpolation de haute qualité basée sur une fonction sinc. Elle considère un voisinage encore plus grand (généralement 8x8) pour produire des résultats très nets, mais avec un coût de calcul plus élevé.",
                    lanczos_pros: ["Netteté supérieure et préservation des détails", "Minimise efficacement les artefacts d'aliasing", "Conserve plus d'informations à travers de multiples transformations"],
                    lanczos_cons: ["Très gourmande en calculs (lente)", "Peut produire des artefacts d'« anneau » notables le long des bords forts"],
                    lanczos_artifact: "Artefacts d'Anneau",
                    lanczos_bestFor: "Mise à l'échelle de qualité archivistique, suréchantillonnage vidéo et scénarios où une préservation maximale des détails est critique.",
                    area_title: "Interpolation de Zone (cv2.INTER_AREA)",
                    area_description: "Une méthode spécialisée principalement pour le sous-échantillonnage (réduction d'images). Elle rééchantillonne en considérant la relation de zone de pixels, en moyennant efficacement les valeurs de pixels dans une zone source pour créer un seul pixel dans la destination.",
                    area_pros: ["Produit des résultats nets et sans artefacts lors de la réduction de taille", "Excellent pour prévenir les motifs de moiré", "Spécifiquement conçue pour la réduction"],
                    area_cons: ["Performances très médiocres pour la mise à l'échelle (similaire à Plus Proche Voisin)"],
                    area_artifact: "Mauvaise qualité lors de la mise à l'échelle",
                    area_bestFor: "Exclusivement pour la réduction d'images. C'est la méthode recommandée pour cette tâche dans OpenCV.",
                    tab_key_characteristics: "Caractéristiques Clés :",
                    tab_primary_artifact: "Artefact Principal :",
                    tab_best_for: "Meilleur Pour :",
                    scaling_direction_section_title: "La Direction de Mise à l'Échelle Compte",
                    scaling_direction_section_description: "Les défis et les meilleures pratiques pour redimensionner une image sont fondamentalement différents selon que vous la réduisez (sous-échantillonnage) ou l'agrandissez (suréchantillonnage). Choisir la bonne méthode d'interpolation pour la tâche est essentiel pour obtenir des résultats de haute qualité.",
                    downscaling_title: "▼ Sous-échantillonnage (Réduction)",
                    downscaling_description: "Le sous-échantillonnage supprime des informations de pixels. Le principal défi est de le faire avec élégance sans introduire d'artefacts disgracieux. La clé est l'",
                    anti_aliasing_bold: "anti-aliasing",
                    downscaling_recommended_title: "Méthodes Recommandées :",
                    downscaling_area_method: "Zone (`cv2.INTER_AREA`) :",
                    downscaling_area_desc: "La référence. Moyenne les valeurs de pixels sur une zone, produisant des résultats nets et propres avec un minimum d'artefacts.",
                    downscaling_lanczos_bicubic_method: "Lanczos/Bicubique avec Anti-aliasing :",
                    downscaling_lanczos_bicubic_desc: "Interpolateurs de haute qualité, lorsqu'ils sont associés à un filtre anti-aliasing (comme dans Pillow ou Scikit-image), donnent également d'excellents résultats.",
                    upscaling_title: "▲ Suréchantillonnage (Agrandissement)",
                    upscaling_description: "Le suréchantillonnage crée de nouveaux pixels par estimation. Il est crucial de noter que les méthodes traditionnelles ",
                    cannot_create_info_bold: "ne peuvent pas créer de nouvelles informations",
                    upscaling_recommended_title: "Méthodes Recommandées :",
                    upscaling_bicubic_method: "Bicubique (`cv2.INTER_CUBIC`) :",
                    upscaling_bicubic_desc: "Un excellent équilibre entre qualité et performance. Il considère 16 pixels environnants pour produire des résultats plus nets que le Bilinéaire.",
                    upscaling_lanczos_method: "Lanczos (`cv2.INTER_LANCZOS4`) :",
                    upscaling_lanczos_desc: "Offre souvent la plus haute qualité pour la mise à l'échelle, préservant exceptionnellement bien les détails fins, mais est plus coûteuse en calculs.",
                    advanced_section_title: "Au-delà de l'Interpolation : Techniques Avancées",
                    advanced_section_description: "Lorsque les méthodes traditionnelles atteignent leurs limites de qualité, les techniques avancées et sensibles au contenu offrent une voie à suivre. Ces méthodes analysent le contenu de l'image pour effectuer un redimensionnement plus intelligent, en particulier pour les scénarios complexes ou critiques pour la qualité.",
                    seam_carving_title: "Redimensionnement sensible au contenu (Seam Carving)",
                    seam_carving_description: "Au lieu d'une mise à l'échelle uniforme, cette technique identifie et supprime ou duplique des \"coutures\", qui sont des chemins de pixels de faible importance. Elle redimensionne l'image de manière non uniforme, protégeant les objets importants de la distorsion. C'est idéal pour modifier le rapport d'aspect d'une image sans écraser le sujet principal.",
                    seam_carving_use_case: "Cas d'utilisation : Changement de rapport d'aspect tout en préservant les sujets",
                    super_resolution_title: "Super-Résolution (Apprentissage Profond)",
                    super_resolution_description: "C'est la solution moderne au problème de la mise à l'échelle. Au lieu de simplement interpoler, les modèles d'apprentissage profond sont entraînés à \"halluciner\" des détails haute fréquence plausibles. Ils ajoutent véritablement de nouvelles informations réalistes, ce qui permet des agrandissements considérablement plus nets et plus détaillés que ce que n'importe quelle méthode traditionnelle peut réaliser.",
                    super_resolution_use_case: "Cas d'utilisation : Agrandissement d'images à grande échelle et de haute qualité",
                    footer_line1: "Guide interactif créé à partir du rapport \"Méthodes de Redimensionnement d'Images Python\".",
                    footer_line2: "Conçu pour rendre les concepts complexes de traitement d'images accessibles et compréhensibles."
                },
                ar: {
                    page_title: "الدليل التفاعلي لتغيير حجم الصور في بايثون",
                    header_title: "تغيير حجم الصور في بايثون",
                    nav_fundamentals: "الأساسيات",
                    nav_interpolation: "الاستيفاء",
                    nav_scaling_direction: "اتجاه التحجيم",
                    nav_advanced: "متقدم",
                    nav_placeholder: "تصفح...",
                    hero_title: "إتقان تغيير حجم الصور",
                    hero_description: "دليل تفاعلي لطرق ومفاضلات ومكتبات تغيير حجم الصور في بايثون. تجاوز التحجيم البسيط وتعلم كيفية اختيار التقنية الصحيحة للحصول على جودة وأداء أمثل.",
                    fundamentals_section_title: "الأساسيات",
                    fundamentals_section_description: "قبل الغوص في الكود، من الضروري فهم المفاهيم الأساسية والأدوات الرئيسية المتاحة. يغطي هذا القسم 'ماذا' و 'لماذا' تغيير الحجم ويقدم مكتبات بايثون الرئيسية التي ستواجهها.",
                    why_resize_title: "لماذا تغيير الحجم؟ المفاهيم الأساسية",
                    why_resize_description: "تغيير حجم الصورة هو عملية تغيير أبعاد الصورة. إنها مهمة أساسية مدفوعة بهدفين رئيسيين: تحسين الأداء (مثل ملفات أصغر لمواقع الويب) وإعداد البيانات (مثل توحيد الأحجام لنماذج التعلم الآلي).",
                    aspect_ratio_rule_title: "القاعدة الذهبية: نسبة العرض إلى الارتفاع",
                    aspect_ratio_rule_description: "الحفاظ على نسبة العرض إلى الارتفاع (العلاقة التناسبية بين العرض والارتفاع) أمر بالغ الأهمية. يؤدي تمديد أو ضغط الصورة بتجاهل أبعادها الأصلية إلى التشويه. القرار الأول في أي عملية تغيير حجم هو ما إذا كان يجب الحفاظ على هذه النسبة.",
                    python_toolbox_title: "صندوق أدوات بايثون",
                    python_toolbox_description: "يوفر نظام بايثون البيئي العديد من المكتبات القوية لمعالجة الصور. بينما تحقق أهدافًا متشابهة، تختلف واجهات برمجة التطبيقات وسلوكياتها الافتراضية بشكل كبير، مما يتطلب عناية دقيقة.",
                    pillow_title: "Pillow (فرع PIL)",
                    pillow_description: "مكتبة سهلة الاستخدام وذات أغراض عامة. يمكن لطريقتها `resize()` تشويه نسبة العرض إلى الارتفاع، بينما تحافظ عليها `thumbnail()`.",
                    opencv_title: "OpenCV",
                    opencv_description: "قوة في رؤية الكمبيوتر. `cv2.resize()` متعددة الاستخدامات ولكنها تتطلب معالجة دقيقة للمعلمات للحفاظ على نسبة العرض إلى الارتفاع.",
                    scikit_image_title: "Scikit-image",
                    scikit_image_description: "مصممة للتحليل العلمي، وتوفر تغيير حجم قوي مع ضوابط صريحة لمكافحة التعرج (anti-aliasing) الضرورية لتصغير الحجم بجودة عالية.",
                    interpolation_section_title: "التقنية الأساسية: الاستيفاء",
                    interpolation_section_description: "الاستيفاء هو القلب الرياضي لتغيير الحجم - وهو كيف يتم تقدير قيم البكسل الجديدة. تؤثر الطريقة التي تختارها بشكل مباشر على الجودة النهائية للصورة وسرعة المعالجة والآثار البصرية الناتجة. لا توجد طريقة \"أفضل\" واحدة؛ إنها دائمًا مقايضة.",
                    comparison_chart_title: "مقارنة الطرق: الجودة مقابل السرعة",
                    chart_quality_label: "الجودة النسبية",
                    chart_speed_label: "السرعة النسبية",
                    tab_nearest: "أقرب جار",
                    tab_bilinear: "ثنائي الخط",
                    tab_bicubic: "ثنائي التكعيب",
                    tab_lanczos: "لانكوز",
                    tab_area: "المساحة",
                    nearest_title: "استيفاء أقرب جار",
                    nearest_description: "الطريقة الأبسط والأسرع. تُعيّن للبكسل الجديد القيمة الدقيقة للبكسل الوحيد الأقرب من الصورة الأصلية. من الناحية المفاهيمية، إنها تجعل البكسلات الموجودة أكبر.",
                    nearest_pros: ["سريعة للغاية، الحد الأدنى من المعالجة", "تحافظ على الحواف الحادة دون تشويش", "جيدة لفن البكسل والبيانات المنفصلة"],
                    nearest_cons: ["تنتج نتائج مربعة ومتعرجة ('jaggies')", "تفتقر إلى النعومة، غير جذابة بصريًا للصور"],
                    nearest_artifact: "التكتل والحواف المتعرجة",
                    nearest_bestFor: "تطبيقات الوقت الفعلي، تحجيم فن البكسل، أو عندما تكون السرعة هي الشغل الشاغل الوحيد.",
                    bilinear_title: "الاستيفاء ثنائي الخط",
                    bilinear_description: "خطوة للأمام في الجودة. يحسب قيمة البكسل الجديد عن طريق أخذ متوسط مرجح لأقرب 4 (2x2) بكسلات محيطة. ينتج نتائج أكثر سلاسة بكثير من أقرب جار.",
                    bilinear_pros: ["توازن جيد بين السرعة والجودة", "يقلل بشكل كبير من التعرج", "سريع نسبيًا"],
                    bilinear_cons: ["يمكن أن يؤدي إلى بعض التعتيم", "يفقد بعض التفاصيل الدقيقة مقارنة بالطرق الأكثر تقدمًا"],
                    bilinear_artifact: "التمويه",
                    bilinear_bestFor: "تغيير حجم الأغراض العامة حيث يلزم حل وسط جيد بين السرعة والجودة.",
                    bicubic_title: "الاستيفاء ثنائي التكعيب",
                    bicubic_description: "طريقة استيفاء أكثر تقدمًا تأخذ في الاعتبار جوار 4x4 من 16 بكسل. تستخدم حسابات أكثر تعقيدًا (متعددات الحدود التكعيبية) لإنتاج صور أكثر وضوحًا وتفصيلاً.",
                    bicubic_pros: ["جودة ممتازة مع احتفاظ كبير بالتفاصيل", "تنتج تدرجات أكثر سلاسة من ثنائي الخط", "غالبًا ما تكون 'النقطة المثلى' للجودة"],
                    bicubic_cons: ["أبطأ بكثير من ثنائي الخط", "يمكن أن تخلق 'هالات' أو 'تجاوزات' على طول الحواف الحادة"],
                    bicubic_artifact: "التجاوز / الهالة",
                    bicubic_bestFor: "تكبير الصور عالية الجودة والتطبيقات الاحترافية حيث تكون الجودة أولوية.",
                    lanczos_title: "استيفاء لانكوز",
                    lanczos_description: "طريقة استيفاء عالية الجودة تعتمد على دالة سينك. تأخذ في الاعتبار جوارًا أكبر (عادةً 8x8) لإنتاج نتائج واضحة جدًا، ولكن بتكلفة حسابية أعلى.",
                    lanczos_pros: ["وضوح فائق وحفظ التفاصيل", "يقلل بشكل فعال من آثار التعرج", "يحتفظ بمزيد من المعلومات عبر تحويلات متعددة"],
                    lanczos_cons: ["مكلفة للغاية من الناحية الحسابية (بطيئة)", "يمكن أن تنتج 'آثار رنين' ملحوظة على طول الحواف القوية"],
                    lanczos_artifact: "آثار الرنين",
                    lanczos_bestFor: "تحجيم بجودة أرشيفية، وتكبير الفيديو، والسيناريوهات التي يكون فيها الحفاظ على أقصى تفاصيل أمرًا بالغ الأهمية.",
                    area_title: "استيفاء المنطقة (cv2.INTER_AREA)",
                    area_description: "طريقة متخصصة مخصصة بشكل أساسي لتصغير الحجم (تقليص الصور). تقوم بإعادة تشكيل الصورة من خلال مراعاة العلاقة بين مناطق البكسل، مما يؤدي إلى متوسط قيم البكسل في منطقة المصدر لإنشاء بكسل واحد في الوجهة.",
                    area_pros: ["تنتج نتائج واضحة وخالية من الشوائب عند تقليل الحجم", "ممتازة في منع أنماط مواريه", "مصممة خصيصًا للتقليص"],
                    area_cons: ["أدائها ضعيف جدًا في التكبير (مشابه لأقرب جار)"],
                    area_artifact: "جودة رديئة عند التكبير",
                    area_bestFor: "حصريًا لتقليص / تصغير حجم الصور. إنها الطريقة الموصى بها لهذه المهمة في OpenCV.",
                    tab_key_characteristics: "الخصائص الرئيسية:",
                    tab_primary_artifact: "الآثار الأساسية:",
                    tab_best_for: "الأفضل لـ:",
                    scaling_direction_section_title: "اتجاه التحجيم يهم",
                    scaling_direction_section_description: "تختلف التحديات وأفضل الممارسات لتغيير حجم الصورة اختلافًا جوهريًا اعتمادًا على ما إذا كنت تقوم بتصغيرها (تصغير الحجم) أو تكبيرها (تكبير الحجم). يعد اختيار طريقة الاستيفاء الصحيحة للمهمة أمرًا بالغ الأهمية لتحقيق نتائج عالية الجودة.",
                    downscaling_title: "▼ تصغير الحجم (التقليص)",
                    downscaling_description: "يتخلص تصغير الحجم من معلومات البكسل. التحدي الرئيسي هو القيام بذلك برشاقة دون إدخال آثار قبيحة. المفتاح هو ",
                    anti_aliasing_bold: "مكافحة التعرج",
                    downscaling_recommended_title: "الطرق الموصى بها:",
                    downscaling_area_method: "المساحة (`cv2.INTER_AREA`):",
                    downscaling_area_desc: "المعيار الذهبي. تُعد قيم البكسل في منطقة ما، مما ينتج عنه نتائج نظيفة وحادة بأقل قدر من الآثار.",
                    downscaling_lanczos_bicubic_method: "لانكوز / ثنائي التكعيب مع مكافحة التعرج:",
                    downscaling_lanczos_bicubic_desc: "تُعد طرق الاستيفاء عالية الجودة، عند دمجها مع مرشح مكافحة التعرج (كما هو الحال في Pillow أو Scikit-image)، نتائج ممتازة أيضًا.",
                    upscaling_title: "▲ تكبير الحجم (التكبير)",
                    upscaling_description: "يُنشئ تكبير الحجم بكسلات جديدة من خلال التقدير. الأهم من ذلك، أن الطرق التقليدية ",
                    cannot_create_info_bold: "لا يمكنها إنشاء معلومات جديدة",
                    upscaling_recommended_title: "الطرق الموصى بها:",
                    upscaling_bicubic_method: "ثنائي التكعيب (`cv2.INTER_CUBIC`):",
                    upscaling_bicubic_desc: "توازن رائع بين الجودة والأداء. تأخذ 16 بكسل محيطة لإنتاج نتائج أكثر وضوحًا من ثنائي الخط.",
                    upscaling_lanczos_method: "لانكوز (`cv2.INTER_LANCZOS4`):",
                    upscaling_lanczos_desc: "غالبًا ما يوفر أعلى جودة للتكبير، مع الحفاظ على التفاصيل الدقيقة بشكل استثنائي، ولكنه أكثر تكلفة من الناحية الحسابية.",
                    advanced_section_title: "ما وراء الاستيفاء: التقنيات المتقدمة",
                    advanced_section_description: "عندما تصل الطرق التقليدية إلى حدود جودتها، توفر التقنيات المتقدمة الواعية بالمحتوى مسارًا إلى الأمام. تحلل هذه الطرق محتوى الصورة لإجراء تغيير حجم أكثر ذكاءً، خاصة للسيناريوهات المعقدة أو الحرجة من حيث الجودة.",
                    seam_carving_title: "تغيير الحجم الواعي بالمحتوى (نحت الدرزات)",
                    seam_carving_description: "بدلاً من التحجيم الموحد، تحدد هذه التقنية وتزيل أو تكرر 'درزات'، وهي مسارات من البكسلات ذات الأهمية المنخفضة. تقوم بتغيير حجم الصورة بشكل غير موحد، مما يحمي الكائنات المهمة من التشويه. وهذا مثالي لتغيير نسبة العرض إلى الارتفاع للصورة دون ضغط الموضوع الرئيسي.",
                    seam_carving_use_case: "حالة الاستخدام: تغيير نسبة العرض إلى الارتفاع مع الحفاظ على الموضوعات",
                    super_resolution_title: "الدقة الفائقة (التعلم العميق)",
                    super_resolution_description: "هذا هو الحل الحديث لمشكلة التكبير. بدلاً من مجرد الاستيفاء، يتم تدريب نماذج التعلم العميق على 'هلوسة' تفاصيل عالية التردد معقولة. إنها تضيف معلومات جديدة وواقعية حقًا، مما يؤدي إلى تكبيرات أكثر وضوحًا وتفصيلاً بشكل كبير مما يمكن لأي طريقة تقليدية تحقيقه.",
                    super_resolution_use_case: "حالة الاستخدام: تكبير الصور عالي الجودة على نطاق واسع",
                    footer_line1: "دليل تفاعلي تم إنشاؤه من تقرير \"طرق تغيير حجم الصور في بايثون\".",
                    footer_line2: "مصمم لجعل مفاهيم معالجة الصور المعقدة سهلة الوصول والفهم."
                }
            };

            let currentLanguage = 'en';
            let interpolationChartInstance = null;

            const interpolationTabsData = {
                nearest: {
                    title_key: 'nearest_title',
                    description_key: 'nearest_description',
                    pros_keys: ["nearest_pros_0", "nearest_pros_1", "nearest_pros_2"],
                    cons_keys: ["nearest_cons_0", "nearest_cons_1"],
                    artifact_key: "nearest_artifact",
                    bestFor_key: "nearest_bestFor"
                },
                bilinear: {
                    title_key: 'bilinear_title',
                    description_key: 'bilinear_description',
                    pros_keys: ["bilinear_pros_0", "bilinear_pros_1", "bilinear_pros_2"],
                    cons_keys: ["bilinear_cons_0", "bilinear_cons_1"],
                    artifact_key: "bilinear_artifact",
                    bestFor_key: "bilinear_bestFor"
                },
                bicubic: {
                    title_key: 'bicubic_title',
                    description_key: 'bicubic_description',
                    pros_keys: ["bicubic_pros_0", "bicubic_pros_1", "bicubic_pros_2"],
                    cons_keys: ["bicubic_cons_0", "bicubic_cons_1"],
                    artifact_key: "bicubic_artifact",
                    bestFor_key: "bicubic_bestFor"
                },
                lanczos: {
                    title_key: 'lanczos_title',
                    description_key: 'lanczos_description',
                    pros_keys: ["lanczos_pros_0", "lanczos_pros_1", "lanczos_pros_2"],
                    cons_keys: ["lanczos_cons_0", "lanczos_cons_1"],
                    artifact_key: "lanczos_artifact",
                    bestFor_key: "lanczos_bestFor"
                },
                area: {
                    title_key: 'area_title',
                    description_key: 'area_description',
                    pros_keys: ["area_pros_0", "area_pros_1", "area_pros_2"],
                    cons_keys: ["area_cons_0"],
                    artifact_key: "area_artifact",
                    bestFor_key: "area_bestFor"
                }
            };

            function getTranslation(key, lang = currentLanguage) {
                const parts = key.split('_');
                let value = translations[lang];
                for (let i = 0; i < parts.length; i++) {
                    if (value && value.hasOwnProperty(parts[i])) {
                        value = value[parts[i]];
                    } else if (value && Array.isArray(value)) { // Handle array elements
                        const index = parseInt(parts[i], 10);
                        if (!isNaN(index) && value.length > index) {
                            value = value[index];
                        } else {
                            return null; // Key not found
                        }
                    } else {
                        return null; // Key not found
                    }
                }
                return value;
            }


            function applyTranslations(lang) {
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    const translation = getTranslation(key, lang);
                    if (translation) {
                        if (element.tagName === 'OPTION') {
                            element.textContent = translation;
                        } else {
                            element.innerHTML = translation;
                        }
                    }
                });

                document.getElementById('page-title').textContent = getTranslation('page_title', lang);
                document.documentElement.lang = lang; // Set HTML lang attribute

                // Update text direction for RTL languages
                if (lang === 'ar') {
                    document.body.classList.add('rtl');
                    document.body.classList.remove('ltr');
                    document.body.style.direction = 'rtl';
                    document.body.style.textAlign = 'right';
                } else {
                    document.body.classList.remove('rtl');
                    document.body.classList.add('ltr');
                    document.body.style.direction = 'ltr';
                    document.body.style.textAlign = 'left';
                }

                // Update tab content for the currently active tab
                const activeTabButton = document.querySelector('.tab-active');
                if (activeTabButton) {
                    updateTabContent(activeTabButton.dataset.tab);
                } else {
                    // Default to bicubic if no tab is active
                    updateTabContent('bicubic');
                }

                // Update Chart.js labels
                if (interpolationChartInstance) {
                    interpolationChartInstance.data.datasets[0].label = getTranslation('chart_quality_label', lang);
                    interpolationChartInstance.data.datasets[1].label = getTranslation('chart_speed_label', lang);
                    interpolationChartInstance.options.scales.y.ticks.callback = function(value) {
                        return value + '%';
                    };
                    interpolationChartInstance.options.plugins.tooltip.callbacks.label = function(context) {
                        let label = context.dataset.label || '';
                        if (label) {
                            label += ': ';
                        }
                        if (context.parsed.y !== null) {
                            label += context.parsed.y + '%';
                        }
                        return label;
                    };
                    interpolationChartInstance.update();
                }
            }

            const tabContainer = document.getElementById('tabs-container');
            const tabButtons = tabContainer.querySelectorAll('.tab');
            const tabContentEl = document.getElementById('tab-content');

            function updateTabContent(tabKey) {
                const contentKeys = interpolationTabsData[tabKey];
                if (!contentKeys) return;

                const title = getTranslation(contentKeys.title_key);
                const description = getTranslation(contentKeys.description_key);
                const artifact = getTranslation(contentKeys.artifact_key);
                const bestFor = getTranslation(contentKeys.bestFor_key);

                const prosHtml = contentKeys.pros_keys.map(key => {
                    const text = getTranslation(key);
                    return text ? `<li class="flex items-start"><span class="text-green-500 mr-2 mt-1">✓</span><span class="text-slate-600">${text}</span></li>` : '';
                }).join('');

                const consHtml = contentKeys.cons_keys.map(key => {
                    const text = getTranslation(key);
                    return text ? `<li class="flex items-start"><span class="text-red-500 mr-2 mt-1">✗</span><span class="text-slate-600">${text}</span></li>` : '';
                }).join('');

                tabContentEl.innerHTML = `
                    <h4 class="text-xl font-semibold text-slate-800 mb-2">${title}</h4>
                    <p class="text-slate-600 mb-4">${description}</p>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div>
                            <h5 class="font-semibold text-slate-700 mb-2" data-i18n="tab_key_characteristics">${getTranslation('tab_key_characteristics')}</h5>
                            <ul class="space-y-2">
                                ${prosHtml}
                                ${consHtml}
                            </ul>
                        </div>
                        <div class="bg-slate-50 p-4 rounded-lg">
                            <h5 class="font-semibold text-slate-700 mb-2" data-i18n="tab_primary_artifact">${getTranslation('tab_primary_artifact')}</h5>
                            <p class="font-mono text-rose-600 bg-rose-50 px-2 py-1 rounded inline-block mb-4">${artifact}</p>
                            <h5 class="font-semibold text-slate-700 mb-2" data-i18n="tab_best_for">${getTranslation('tab_best_for')}</h5>
                            <p class="text-slate-600">${bestFor}</p>
                        </div>
                    </div>
                `;
            }

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabKey = button.dataset.tab;
                    tabButtons.forEach(btn => {
                        btn.classList.remove('tab-active');
                        btn.classList.add('tab-inactive');
                    });
                    button.classList.add('tab-active');
                    button.classList.remove('tab-inactive');
                    updateTabContent(tabKey);
                });
            });
            
            // Initialize chart
            const ctx = document.getElementById('interpolationChart').getContext('2d');
            interpolationChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Nearest', 'Bilinear', 'Bicubic', 'Lanczos'],
                    datasets: [{
                        label: 'Relative Quality',
                        data: [20, 50, 85, 95],
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1
                    }, {
                        label: 'Relative Speed',
                        data: [100, 80, 40, 20],
                        backgroundColor: 'rgba(239, 68, 68, 0.6)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                             ticks: {
                                callback: function(value) {
                                    return value + '%'
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                             callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
            
            const mobileNav = document.getElementById('mobile-nav');
            mobileNav.addEventListener('change', () => {
                const targetId = mobileNav.value;
                if (targetId) {
                    const targetElement = document.querySelector(targetId);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth' });
                    }
                }
            });

            const languageSelector = document.getElementById('language-selector');
            languageSelector.addEventListener('change', (event) => {
                currentLanguage = event.target.value;
                applyTranslations(currentLanguage);
            });

            // Initial application of translations
            applyTranslations(currentLanguage); // Apply default 'en' translations first
            updateTabContent('bicubic'); // Set initial tab content
            tabContainer.querySelector('[data-tab="bicubic"]').classList.add('tab-active');
            tabContainer.querySelector('[data-tab="bicubic"]').classList.remove('tab-inactive');


            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                        observer.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.1 });

            document.querySelectorAll('.section-fade-in').forEach(section => {
                observer.observe(section);
            });
            
            // Initial animation for the first section
            setTimeout(() => {
                 document.querySelector('.section-fade-in').classList.add('visible');
            }, 100);

            // Three.js Background Setup
            let scene, camera, renderer, particles;
            const particleCount = 500; // Number of particles

            function initThreeJS() {
                const container = document.getElementById('threejs-background');
                const width = container.clientWidth;
                const height = container.clientHeight;

                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.z = 100;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha: true for transparent background
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);

                // Particles
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const color1 = new THREE.Color(0xADD8E6); // Light blue
                const color2 = new THREE.Color(0xFFFFFF); // White
                const color3 = new THREE.Color(0xA9A9A9); // Dark Gray

                for (let i = 0; i < particleCount; i++) {
                    // Positions
                    const x = (Math.random() * 2 - 1) * 500;
                    const y = (Math.random() * 2 - 1) * 500;
                    const z = (Math.random() * 2 - 1) * 500;
                    positions.push(x, y, z);

                    // Colors
                    const rand = Math.random();
                    if (rand < 0.33) {
                        colors.push(color1.r, color1.g, color1.b);
                    } else if (rand < 0.66) {
                        colors.push(color2.r, color2.g, color2.b);
                    } else {
                        colors.push(color3.r, color3.g, color3.b);
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });

                particles = new THREE.Points(geometry, material);
                scene.add(particles);

                // Lights (optional, but can add subtle depth)
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(0, 0, 100);
                scene.add(directionalLight);

                animateThreeJS();
            }

            function animateThreeJS() {
                requestAnimationFrame(animateThreeJS);

                // Animate particles
                if (particles) {
                    particles.rotation.y += 0.0005;
                    particles.rotation.x += 0.0001;
                }

                renderer.render(scene, camera);
            }

            function onWindowResize() {
                const container = document.getElementById('threejs-background');
                const width = container.clientWidth;
                const height = container.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }

            // Start Three.js only after window is loaded
            window.onload = function () {
                initThreeJS();
                window.addEventListener('resize', onWindowResize);
                // Ensure initial Chart.js setup and translations run
                applyTranslations(currentLanguage);
                updateTabContent('bicubic');
                tabContainer.querySelector('[data-tab="bicubic"]').classList.add('tab-active');
                tabContainer.querySelector('[data-tab="bicubic"]').classList.remove('tab-inactive');
            };
        });
    </script>
</body>
</html>
